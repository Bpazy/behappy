// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/Bpazy/behappy/ent/subscriptionmatch"
)

// SubscriptionMatch is the model entity for the SubscriptionMatch schema.
type SubscriptionMatch struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// MatchID holds the value of the "match_id" field.
	MatchID int64 `json:"match_id,omitempty"`
	// PlayerID holds the value of the "player_id" field.
	PlayerID string `json:"player_id,omitempty"`
	// PlayerSlot holds the value of the "player_slot" field.
	PlayerSlot int `json:"player_slot,omitempty"`
	// RadiantWin holds the value of the "radiant_win" field.
	RadiantWin bool `json:"radiant_win,omitempty"`
	// Duration holds the value of the "duration" field.
	Duration int `json:"duration,omitempty"`
	// GameMode holds the value of the "game_mode" field.
	GameMode int `json:"game_mode,omitempty"`
	// LobbyType holds the value of the "lobby_type" field.
	LobbyType int `json:"lobby_type,omitempty"`
	// HeroID holds the value of the "hero_id" field.
	HeroID int `json:"hero_id,omitempty"`
	// StartTime holds the value of the "start_time" field.
	StartTime int `json:"start_time,omitempty"`
	// Version holds the value of the "version" field.
	Version int `json:"version,omitempty"`
	// Kills holds the value of the "kills" field.
	Kills int `json:"kills,omitempty"`
	// Deaths holds the value of the "deaths" field.
	Deaths int `json:"deaths,omitempty"`
	// Assists holds the value of the "assists" field.
	Assists int `json:"assists,omitempty"`
	// Skill holds the value of the "skill" field.
	Skill *int `json:"skill,omitempty"`
	// LeaverStatus holds the value of the "leaver_status" field.
	LeaverStatus int `json:"leaver_status,omitempty"`
	// PartySize holds the value of the "party_size" field.
	PartySize int `json:"party_size,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*SubscriptionMatch) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case subscriptionmatch.FieldRadiantWin:
			values[i] = new(sql.NullBool)
		case subscriptionmatch.FieldID, subscriptionmatch.FieldMatchID, subscriptionmatch.FieldPlayerSlot, subscriptionmatch.FieldDuration, subscriptionmatch.FieldGameMode, subscriptionmatch.FieldLobbyType, subscriptionmatch.FieldHeroID, subscriptionmatch.FieldStartTime, subscriptionmatch.FieldVersion, subscriptionmatch.FieldKills, subscriptionmatch.FieldDeaths, subscriptionmatch.FieldAssists, subscriptionmatch.FieldSkill, subscriptionmatch.FieldLeaverStatus, subscriptionmatch.FieldPartySize:
			values[i] = new(sql.NullInt64)
		case subscriptionmatch.FieldPlayerID:
			values[i] = new(sql.NullString)
		case subscriptionmatch.FieldCreateTime, subscriptionmatch.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type SubscriptionMatch", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the SubscriptionMatch fields.
func (sm *SubscriptionMatch) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case subscriptionmatch.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			sm.ID = int(value.Int64)
		case subscriptionmatch.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				sm.CreateTime = value.Time
			}
		case subscriptionmatch.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				sm.UpdateTime = value.Time
			}
		case subscriptionmatch.FieldMatchID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field match_id", values[i])
			} else if value.Valid {
				sm.MatchID = value.Int64
			}
		case subscriptionmatch.FieldPlayerID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field player_id", values[i])
			} else if value.Valid {
				sm.PlayerID = value.String
			}
		case subscriptionmatch.FieldPlayerSlot:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field player_slot", values[i])
			} else if value.Valid {
				sm.PlayerSlot = int(value.Int64)
			}
		case subscriptionmatch.FieldRadiantWin:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field radiant_win", values[i])
			} else if value.Valid {
				sm.RadiantWin = value.Bool
			}
		case subscriptionmatch.FieldDuration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration", values[i])
			} else if value.Valid {
				sm.Duration = int(value.Int64)
			}
		case subscriptionmatch.FieldGameMode:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field game_mode", values[i])
			} else if value.Valid {
				sm.GameMode = int(value.Int64)
			}
		case subscriptionmatch.FieldLobbyType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field lobby_type", values[i])
			} else if value.Valid {
				sm.LobbyType = int(value.Int64)
			}
		case subscriptionmatch.FieldHeroID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field hero_id", values[i])
			} else if value.Valid {
				sm.HeroID = int(value.Int64)
			}
		case subscriptionmatch.FieldStartTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field start_time", values[i])
			} else if value.Valid {
				sm.StartTime = int(value.Int64)
			}
		case subscriptionmatch.FieldVersion:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				sm.Version = int(value.Int64)
			}
		case subscriptionmatch.FieldKills:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field kills", values[i])
			} else if value.Valid {
				sm.Kills = int(value.Int64)
			}
		case subscriptionmatch.FieldDeaths:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deaths", values[i])
			} else if value.Valid {
				sm.Deaths = int(value.Int64)
			}
		case subscriptionmatch.FieldAssists:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field assists", values[i])
			} else if value.Valid {
				sm.Assists = int(value.Int64)
			}
		case subscriptionmatch.FieldSkill:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field skill", values[i])
			} else if value.Valid {
				sm.Skill = new(int)
				*sm.Skill = int(value.Int64)
			}
		case subscriptionmatch.FieldLeaverStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field leaver_status", values[i])
			} else if value.Valid {
				sm.LeaverStatus = int(value.Int64)
			}
		case subscriptionmatch.FieldPartySize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field party_size", values[i])
			} else if value.Valid {
				sm.PartySize = int(value.Int64)
			}
		}
	}
	return nil
}

// Update returns a builder for updating this SubscriptionMatch.
// Note that you need to call SubscriptionMatch.Unwrap() before calling this method if this SubscriptionMatch
// was returned from a transaction, and the transaction was committed or rolled back.
func (sm *SubscriptionMatch) Update() *SubscriptionMatchUpdateOne {
	return (&SubscriptionMatchClient{config: sm.config}).UpdateOne(sm)
}

// Unwrap unwraps the SubscriptionMatch entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sm *SubscriptionMatch) Unwrap() *SubscriptionMatch {
	_tx, ok := sm.config.driver.(*txDriver)
	if !ok {
		panic("ent: SubscriptionMatch is not a transactional entity")
	}
	sm.config.driver = _tx.drv
	return sm
}

// String implements the fmt.Stringer.
func (sm *SubscriptionMatch) String() string {
	var builder strings.Builder
	builder.WriteString("SubscriptionMatch(")
	builder.WriteString(fmt.Sprintf("id=%v, ", sm.ID))
	builder.WriteString("create_time=")
	builder.WriteString(sm.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("update_time=")
	builder.WriteString(sm.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("match_id=")
	builder.WriteString(fmt.Sprintf("%v", sm.MatchID))
	builder.WriteString(", ")
	builder.WriteString("player_id=")
	builder.WriteString(sm.PlayerID)
	builder.WriteString(", ")
	builder.WriteString("player_slot=")
	builder.WriteString(fmt.Sprintf("%v", sm.PlayerSlot))
	builder.WriteString(", ")
	builder.WriteString("radiant_win=")
	builder.WriteString(fmt.Sprintf("%v", sm.RadiantWin))
	builder.WriteString(", ")
	builder.WriteString("duration=")
	builder.WriteString(fmt.Sprintf("%v", sm.Duration))
	builder.WriteString(", ")
	builder.WriteString("game_mode=")
	builder.WriteString(fmt.Sprintf("%v", sm.GameMode))
	builder.WriteString(", ")
	builder.WriteString("lobby_type=")
	builder.WriteString(fmt.Sprintf("%v", sm.LobbyType))
	builder.WriteString(", ")
	builder.WriteString("hero_id=")
	builder.WriteString(fmt.Sprintf("%v", sm.HeroID))
	builder.WriteString(", ")
	builder.WriteString("start_time=")
	builder.WriteString(fmt.Sprintf("%v", sm.StartTime))
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(fmt.Sprintf("%v", sm.Version))
	builder.WriteString(", ")
	builder.WriteString("kills=")
	builder.WriteString(fmt.Sprintf("%v", sm.Kills))
	builder.WriteString(", ")
	builder.WriteString("deaths=")
	builder.WriteString(fmt.Sprintf("%v", sm.Deaths))
	builder.WriteString(", ")
	builder.WriteString("assists=")
	builder.WriteString(fmt.Sprintf("%v", sm.Assists))
	builder.WriteString(", ")
	if v := sm.Skill; v != nil {
		builder.WriteString("skill=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("leaver_status=")
	builder.WriteString(fmt.Sprintf("%v", sm.LeaverStatus))
	builder.WriteString(", ")
	builder.WriteString("party_size=")
	builder.WriteString(fmt.Sprintf("%v", sm.PartySize))
	builder.WriteByte(')')
	return builder.String()
}

// SubscriptionMatches is a parsable slice of SubscriptionMatch.
type SubscriptionMatches []*SubscriptionMatch

func (sm SubscriptionMatches) config(cfg config) {
	for _i := range sm {
		sm[_i].config = cfg
	}
}
